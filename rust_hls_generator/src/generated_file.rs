//! Functions for generating and parsing output files
use rust_hls_core::{hash_comment, synthesized_module_filepath, CrateFile};
mod generate_rust_hdl_struct;
pub use generate_rust_hdl_struct::*;

#[cfg(feature = "verilator")]
type GenerateFileContentResult = (String, CrateFile);
#[cfg(not(feature = "verilator"))]
type GenerateFileContentResult = (String,);

/// Generates a output file from a verilog description
///
/// The hash is added to the file in a comment.
pub fn generate_file_content(
    verilog: &str,
    verilog_main_module: &str,
    struct_name: &str,
    hash: &str,
    parameter_names: &Vec<String>,
    source_module_path: &Vec<String>,
) -> Result<GenerateFileContentResult, GenerateRustHdlStructError> {
    // TODO: Dummy implementation
    let hash_comment = hash_comment(hash);
    let rust_hdl_struct = generate_rust_hdl_struct(
        verilog,
        verilog_main_module,
        struct_name,
        parameter_names,
        source_module_path,
    )?;
    let result: String = format!(
        r##"// This file was generated by rust_hls. Please do not edit it manually.
{}

{}

#[allow(dead_code)]
const VERILOG: &str = r#"{}"#;"##,
        hash_comment,
        prettyplease::unparse(&rust_hdl_struct.rust_file),
        verilog
    )
    .into();
    #[cfg(feature = "verilator")]
    return Ok((result, rust_hdl_struct.cpp_shim));
    #[cfg(not(feature = "verilator"))]
    return Ok((result,));
}

// TODO: This is really hacky
#[cfg(feature = "verilator")]
type GenerateFileResult = (CrateFile, CrateFile);
#[cfg(not(feature = "verilator"))]
type GenerateFileResult = (CrateFile,);

/// Generates a output file from a verilog description
///
/// The hash is added to the file in a comment.
pub fn generate_file(
    source_module_path: &Vec<String>,
    verilog: &str,
    verilog_main_module: &str,
    struct_name: &str,
    hash: &str,
    parameter_names: &Vec<String>,
) -> Result<GenerateFileResult, GenerateRustHdlStructError> {
    let file_name = synthesized_module_filepath(source_module_path);
    let content = generate_file_content(
        verilog,
        verilog_main_module,
        struct_name,
        hash,
        parameter_names,
        source_module_path,
    )?;
    #[cfg(feature = "verilator")]
    return Ok((
        CrateFile {
            path: file_name,
            content: content.0,
        },
        content.1,
    ));
    #[cfg(not(feature = "verilator"))]
    return Ok((CrateFile {
        path: file_name,
        content: content.0,
    },));
}

#[cfg(test)]
mod tests {
    use rust_hls_core::extract_file_hash;

    use super::*;

    #[test]
    fn generate_content_seems_to_work() {
        let generated_file = generate_file_content(
            r#"
        module counter
        (
            input clock,
            output [5:0] led
        );
        
        reg [23:0] clockCounter = 0;
        localparam WAIT_TIME = 1000;
        reg [5:0] ledCounter = 0;
        
        always @(posedge clock) begin
            clockCounter <= clockCounter + 1;
            if (clockCounter == WAIT_TIME) begin
                clockCounter <= 0;
                ledCounter <= ledCounter + 1;
            end
        end
        
        assign led = ~ledCounter;
        endmodule
        "#,
            "counter",
            "Counter",
            "cool_hash",
            &vec![],
            &vec![],
        )
        .unwrap();

        assert!(generated_file.0.contains("struct Counter"));
        assert!(generated_file.0.contains("always @(posedge clock) begin"));
    }

    #[test]
    fn hash_can_be_extracted_from_generated_content() {
        let original_hash = "cool_hash";
        let generated_file = generate_file_content(
            r#"
        module counter
        (
            input clock,
            output [5:0] led
        );
        
        reg [23:0] clockCounter = 0;
        localparam WAIT_TIME = 1000;
        reg [5:0] ledCounter = 0;
        
        always @(posedge clock) begin
            clockCounter <= clockCounter + 1;
            if (clockCounter == WAIT_TIME) begin
                clockCounter <= 0;
                ledCounter <= ledCounter + 1;
            end
        end
        
        assign led = ~ledCounter;
        endmodule
        "#,
            "counter",
            "Counter",
            &original_hash,
            &vec![],
            &vec![],
        )
        .unwrap();

        let extracted_hash = extract_file_hash(&generated_file.0).unwrap();

        assert_eq!(extracted_hash, original_hash);
    }
}
